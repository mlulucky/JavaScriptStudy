<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>자바스크립트의 함수</title>
</head>
<body>
  <h1>연산의 집합 함수(method)</h1>
  <h2>함수의 선언법1</h2>
  <ul>
      <li>function 이름(매개변수) {return 반홥값;} : 작성법</li>
      <li>이름(매개변수); : 호출법 </li>
      <li>이름(undefined); : 매개변수가 있는데 안적으면 매개변수가 undefined 가 된다. </li>
      <li>return; : 을 작성하면 다음 코드가 있어도 함수를 종료한다.</li>
      <li>매개변수 : let을 사용할 필요가 없다. (변수타입 없이 이름만 쓰면 된다)</li> <!-- 예전에는 이름을 지역변수 이름과 동일하게 작성하면 오류가 발생했었는데 지금은 아무문제 없다.  -->
      <li>함수를 선언하면 코드(함수) 실행전에 인터프리터 엔진이 타입인 줄 알고 미리 프로토 타입을 만든다. (호이스팅 현상이 발생)(엔진: 크롬, 엣지, ...)</li>
  </ul>
  <h2>함수의 선언법 2</h2>
  <ul>
      <li>const 함수이름=function(매개변수){return 반환값;} : 이름이 없는 함수를 변수 or 상수가 참조 </li>
      <li>인터프리터 엔진이 함수를 찾지 못해서 미리 프로토 타입을 만들지 않는다.
          (해당 코드(변수)가 실행될때 까지 함수는 미리 만들어 지지 않는다.)</li>
      <li>사람들이 왜 함수가 나중에 선언됐는데 그 앞에서 호출되는가? 오류아닌가? 하는 이슈가 있다 -> 오류를 막으려고 등장한 방식</li>
      <li>메모리를 최초에 실행될때 함수 선언이 너무 많으면 js 실행이 너무 느려져서 우선 실행하면서 함수가 선언되게 하기 위해 사용됨</li>
      <!-- 함수를 끌어다 쓰면 함수가 1000개, 10000개 를 코드가 실행전에 먼저 프로토타입을 만든다  -> 프로토타입을 다 만들기까지 코드 실행x. 위에 코드실행이 느려진다.
      따라서 코드 중간중간에 프로토타입 생성후 코드실행 -> 코드가 순차적이고 코드실행속도를 높인다. -->
  </ul>
  <h2>함수의 선언법 3</h2>
  <ul>
      <li>const 함수이름=(매개변수)=>{return 반환값;} : (이름이 없는)화살표 함수를 변수 or 상수가 참조. (람다식이라고 안하고 화살표함수)</li>
      <li>()->{} : ((프로토)타입 없이 == 객체가 될수없다) 실행만 될 함수를 타입으로 인지하는 js의 문제를 해결하기 위해 일반함수로 화살표 함수를 도입(es6)</li>
      <li>이유? 모든 함수를 프로토 타입으로 인지하면 메모리를 많이 사용하기 때문에 문제가 발생할 수 있다.</li>
      <li>함수와 필드 바인딩문제로 화살표 함수가 등장!</li> <!-- (초초초초초초초초초초 고급!!!) -->
<!--  // 함수 선언 목적 - 1. 타입(대문자)  2. 메소드(실행집합)(소문자. 소문자가 되도 타입이 된다.) - 타입이된다.-->
<!--      타입이 되고싶지 않은데 프로토타입을 만들어버린다-->
<!--      함수가 프로토타입일 필요는 없다. 실행만 되면됨. 프로토타입은 객체. 메모리-->
<!--      ()->{} 프로토타입이 없다-->

  </ul>
  <script>
    /* java 함수
      class Calc {
        public int sum(int a, int b) {
          return a+b;
        }
      }
    */

    // js의 함수 규칙
    // 매개변수에 변수타입를 안쓴다. 반환 타입을 안쓴다.
    console.log(sum(30)); // 30 + undefined => 30+NaN = NaN
    console.log(sum(30,40)); // 어디서든 선언가능
    // console.log(sum2(30,40)); // 에러발생
    // console.log(sum3(30,40)); // 에러발생

    // 3. 화살표 함수 선언 법
    const sum3 = (a,b)=>{ // js의 화살표함수는 프로토타입이 없다!!! 따라서 함수 선언 후에 실행가능하다
      // 프로토타입이 없는 일반 함수((프로토)타입이될 수 없다!!!(== 객체가 될 수 없다(중요)), 순수한 실행의 함수다, 메서드)
      return a+b;
    }
    console.log(sum3(30,40));

    // 1. 이름이 없는 함수를 변수가 참조하는 법 (선언하고 나서 사용가능 : 함수의 호이스팅 현상을 막기위해 / 메모리를 아끼기 위해 사용) // 12년전에 이슈! - 호이스팅현상
    const sum2=function (a,b) { // 프로토타입이 있다 // 함수를 변수에 저장하고 숨겨놓은 것 - JVM 엔진이 모르고 지나간다. 변수를 선언한줄 안다. 함수인줄 모른다.  그래서 함수 선언후에 함수사용가능하다.
      return a+b;
    }

    // 2. 함수를 정의하면서 이름을 짓는 법 (어디서든 선언해도 사용가능 - 함수의 Hoisting 현상)
    console.log(sum2(30,40))
    // 함수는 (프로토)타입이기 때문에 자바스크립트 V8엔진(구글이개발한 인터프리터엔진)이 함수만 찾아서 메모리에 생성 후 저장한다 // 왜? 함수가 (프로토)타입이라서 먼저 메모리에 생성한다.
    // 인터프리터(js 엔진)이 실행하기 전에 모든 타입과 함수를 메소드 영역에 저장. (먼저 메모리에 생성하고 저장.) => 코드의 어떤 위치에서든 실행가능
    // == JVM(java 엔진) 이 실행하기 전에 모든 클래스와 함수를 메소드 영역에 저장. (먼저 메모리에 생성하고 저장.)

    // sum이 (프로토)타입은 아닌데도 함수는 엔진메모리에 참조되면 어느 위치에 있던 실행가능
    function sum(a,b) { // 프로토타입이 있다.
      return a+b;
    }
    console.log(`sum(10,11)= ${sum(10,11)}`); // js에서 문자열을 사용하는 방법

    function Calc() { // Calc 타입의 함수
      this.sum=function(a,b) { // ★ this 필드접근자 : this는 해당 타입이 객체일때 필드접근가능 (중요!!!) // this 는  function Calc() 함수가 new Calc() 객체일때 필드에 접근가능
        return a+b;
      }
    }
    // Calc.sum() 으로 10+11 결과를 출력하세요.
    const calc = new Calc(); // 객체 == 타입.
    console.log(`new Calc().sum(10,11) = ${new Calc().sum(10,11)}`);
    // 타입의 필드를 사용하려면 객체를 만들어야한다
    // 타입 function Calc(), 타입의 필드 sum() 객체 new Calc()
    // 프로토타입 증명
    console.log(sum.prototype);  // 프로토타입 생성
    console.log(sum2.prototype); // 프로토타입 생성
    console.log(sum3.prototype); // undefined // 화살표함수는 프로토타입이 없는 순수 method 이다(상위 1%만 아는 사실)

  </script>
</body>
</html>