<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>event</title>
</head>
<body>
<!-- onemouseleave=function(event){""}  생략되어 있음 --> <!-- on이벤트 = "" 문자열 안에 있는게 function(){""} 함수다. -->
<h1 onmouseenter="event.target.style.color='red';"
    onmouseleave="this.style.color='black';" > <!-- node h1태그에 마우스가 들어가면 / 나가면 이벤트 실행 --> <!-- event.target == this -->
  document 에 event 속성에 대해 알아보자</h1> <!-- document에 이벤트 속성이 들어가 있다. -->
<p>이벤트란 GUI를 제공하는 모든 어플이나 플랫폼에서 제공하는 것(osx(맥킨토시), window, java.swing, browser)</p> <!-- 마우스에서 반응하는것 이벤트 // GUI <-> CUI (커맨드라인인터페이스 : 콘솔창에 뜨는 거) -->
<ul><!--(+ 암기) -->
  <li>GUI : Graphic User Interface 마우스(포인터의 역할)로 화면을 클릭하는 인터페이스를 제공</li>
  <li>+ GUI 이벤트 : 화면을 제어할 때 발생하는 것을 이벤트 (마우스, 키보드 이벤트)</li>
  <li>+ form 이벤트 : 양식을 제출하기 위해 form 요소에서 발생하는 것들 (폼요소의 내용이 change, input, submit...)</li> <!-- change 폼요소의 내용 바뀌는거 -->
  <li>window 이벤트 : 브라우저에서 발생하는 이벤트 (resize,scroll)</li> <!-- resize 브라우저화면 크기 조절 -->
  <li>touch 이벤트 : 손가락의 터치로 발생하는 이벤트 (touch)</li>
  <li>.... 등</li>
  <li>이벤트 리스너 : 이벤트 루프(무한 반복문). 이벤트들이 발생하는 것을 감시한다.</li> <!-- 이벤트 리스너: 이벤트가 발생했을 때 그 처리를 담당하는 함수 --><!-- 자바스크립트의 이벤트리스너가 성능이 좋다 -->
</ul>
<!--
w3schools DOM 마우스 이벤트 종류
https://www.w3schools.com/jsref/obj_mouseevent.asp
-->
<h2>GUI 즉 마우스에서 발생하는 이벤트 속성(+ 암기)</h2>
<ul style="list-style: none;">
  <li onclick="this.style.background='gray'"> <!-- this == 이벤트가 정의된 노드(개체, 객체) 자신 = li 태그 -->
    onclick : 해당 노드에 마우스를 클릭하면 발생 (이벤트 객체로 pointerEvent 를 반환한다)
  </li>
  <li ondblclick="this.style.background='lightblue'">
    ondblclick : 해당 노드에 마우스를 더블 클릭하면 발생
  </li>
  <li onmousedown="this.style.color='purple'">
    onmousedown : 해당 노드에 마우스를 누르고 있는 상태
  </li>
  <li onmouseup="this.style.color='green'; this.style.border='2px dotted'"> <!-- border 의 색상을 지정안하면 글자 색을 따라간다. -->
    onmouseup : 누르고 있던 마우스를 떼는 행위
  </li>
  <li onmouseenter="event.target.style.border='2px solid'">
    <strong>(+)onmouseenter :</strong>  <!-- target은 이벤트 가 발생한 대상(자손포함) -->
    <span>해당 노드에 마우스 포인터가 들어가면</span>
    (자손 노드에 이벤트 버블링이 발생하지 않음)
  </li>
  <li onmouseleave="event.target.style.border='2px solid'">
    <strong>(+)onmouseleave :</strong>
    <span>해당 노드에 있던 마우스 포인터가 나가면</span>
    (자손 노드에 이벤트 버블링이 발생하지 않음)
  </li>
  <li onmouseover="event.target.style.border='2px solid'">
    <strong>(-)onmouseover :</strong>
    <span>해당 노드에 마우스 포인터가 들어가면</span>
    (자손 노드에 이벤트 버블링이 발생함)
    <!-- ▣ 이벤트 전달 개념
      노드를 중첩
      li 태그 안에 strong, span 태그 중첩
      li 태그에 on 이벤트 정의
      li 태그에서 발생한 이벤트가 자손, 자식들에게도 전달이 된다.
      이벤트 버블링(부모태그에 이벤트를 정의했는데 자식요소도 이벤트 target 이 된다)
      속성을 갖는건 아니고 이벤트가 발생하는 것

      모든 이벤트는 이벤트 버블링이 발생 (모든 이벤트는 부모에서 발생한 이벤트가 자손들에게도 똑같이 발생된다) (이벤트가 발생한 target 의 자식요소도 타겟이 된다.)
      버블링 생기는게 정상 // mouseenter, mouseleave가 이벤트 버블링(자손요소까지 이벤트전달)이 생기는걸 막는 것이다.
      실무에서는 mouseenter와 mouseleave를 쓴다
      -->
  </li>
  <!--  <li onmouseout="event.target.style.border='2px solid'">-->
  <li onmouseout="this.style.border='2px solid'"> <!-- this로 스타일을 주면. 이벤트가 정의된 li 태그만 스타일 변경 뜻 // event.target 은 이벤트가 발생한 자손 포함 -->
    <strong>(-)onmouseout :</strong>
    <span>해당 노드에 마우스 포인터가 나가면</span>
    (자손 노드에 이벤트 버블링이 발생함)
  </li>
  <li oncontextmenu="this.style.color='orange'">
    oncontextmenu : 마우스 오른쪽 클릭 (오른쪽 클릭 방지용)
  </li>
</ul>
<h2>이벤트 정의하는 방법</h2>
<ul>
  <li onclick="this.style.textDecoration='overline'">
    1. 요소에 이벤트 속성을 직접 재정의 하는 방법
    (onclick="") == (onclick=function(event){""})  <!-- (event): event라는 이름의 매개변수가 있는것 / " ": 문자열에 써진 코드가 실행 -->
  </li>
  <li id="node1">
    2. script 태그에서 node 찾아서 이벤트 속성을 재정의 (onclick 속성 이름에 직접 재정의 하는 방법)
    node.onclick=function(e){}
    <ul>
      <li>(주의) 노드 탐색은 node 가 생성된 후에 찾아야한다. </li> <!-- 탐색하는 스크립트가 노드 아래에 와야한다. 왜? 만들어진걸 찾아야하는데, 노드는 순서대로 생성되기 때문에(스크립트도 노드) -->
      <li>(주의**) 한 노드에 같은 이벤트는 한번만 정의 가능하다. </li> <!-- (마지막에 정의한 것만 적용된다) -->
      <li>(주의) 콜백함수를 화살표함수로 사용하면 this 선택자를 사용할 수 없다.(개발자도 어렵다)</li> <!-- 콜백함수 : 호출하면 실행되는 함수 -->
      <script>
        const node1 = document.getElementById("node1");
        // 같은 이벤트는 한번만 정의해야 한다. 왜? onclick 속성(필드)는 하나라서, 복수의 이벤트 핸들러 할당할 수 없다
        node1.onclick=function(e){
          this.style.background='lightgreen'; // 적용(x)
        }
        node1.onclick=function(e){
          this.style.color='rgb(200,100,200)'; // 적용(o)
        }
        // 핸들러 제거하고 싶으면 null 값주기 elem.onclick = null;

        // 화살표함수 this 예제
        // node1.onclick=(e)=>{
        //   this.style.color='rgb(20,100,50)'; // 화살표함수 this 사용못함. 에러발생
        // }

        // ▣ 함수를 재사용하려면 - node1ClickHandler 함수를 재정의 하는 방법
        // 1번방법 : node1에 onclick 발생하면 node1ClickHandler 함수를 호출 및 실행하라
        node1.onclick=node1ClickHandler; // 콜백함수 == 이벤트핸들러
        // 2번방법 : node1에 onclick 발생하면 익명함수를 호출하고 익명함수가 node1ClickHandler 를 실행한다.
        // => ★함수 여러개를 실행으로 정의 가능 // onclick 함수 1개 또는 여러개 정의 가능
        node1.onclick=function(e) { // 익명함수 : 이름이 없는 함수
          node1ClickHandler(e);
          a(e);
          b(e);
        }
        // 3번방법 - 잘못된 정의 방법(주의!)
        // node1.onclick=node1ClickHandler(); // 에러
        // 왜? ()괄호는 함수가 실행 -> return값이 들어가서. return 값이 정수인 경우 onclick=13 ? 말이 안된다. 잘못된것.
        function node1ClickHandler(e) {
         // this.style.color='rgb(200,100,200)';
          return 13;
        }
      </script>
    </ul>
  </li>
  <li id="node2">
    3. node.addEventListener("event",function(e){}) : 를 이용해서 이벤트 재정의 <!-- addEventListener() 메소드는 이벤트 리스너 등록을 위한 메소드 -->
    <ul>
      <li>특징1 : 콜백 함수를 여러개 동시에 정의 가능</li>
      <li>특징2 : addEventListener 로만 정의 가능한 이벤트가 존재함(DOMContentLoaded, Wheel,...)</li>
      <li>특징3 : 필드로 함수를 재정의 하는것이 낯설어서 등장했다.</li>
    </ul>
  </li>
  <script>
    // 클릭이벤트 => on을 제외 onclick -> "click"
    // 특징1. 똑같은 이벤트 여러번 정의 가능 ex) node2에 click 이벤트
    node2.addEventListener("click",function(e) { //  callbackfunc1; 콜백함수1
      this.style.textDecoration = 'underline'; // this == 이벤트를 정의한 노드(개체) 자신 == node2
    })
    node2.addEventListener("click",function(e) { // callbackfunc2; 콜백함수2
      this.style.color='blueviolet';
    });

    // ▣ addEventListener() 함수 동작원리
    /* node2.onclick=callbackfunc1; // 한번에 하나씩

       node2.onclick=function(e) { // 함수안에 여러개의 콜백함수 실행  // onclick에 함수 2개를 실행하도록 정의
       // e 에는 클릭(이벤트 발생)을 한것에 대한 이벤트 정보가 들어가있다.
       callbackfunc1(e); // 콜백함수1
       callbackfunc2(e); // 콜백함수2
     }*/

    // node2.onclick=function(e){} 필드로 함수 재정의
    // 여러번 정의 가능하다 - 같은 기능의 함수가 여러개 있어도 모두 적용된다.
  </script>
</ul>
<h2>콜백함수의 매개변수 event</h2>
<p>이벤트 리스너가 콜백함수를 실행할 때 이벤트 정보를 콜백함수에 전달하는 매개변수 (이벤트정보)</p>
<ul>
  <li>e.target : 이벤트가 발생한 요소 (이벤트가 자손에게 전달되어서(이벤트 버블링) 정의한 요소와 발생한 요소가 다르다.)</li>  <!-- 실제클릭한 요소 --> <!-- 정의한 요소 - 부모 / 발생한 요소 - 자손 -->
  <li>e.currentTarget : 이벤트를 정의한 요소 (== 콜백함수의 this)</li> <!-- 현재 이벤트가 실행중인 핸들러 -->
  <li>e.type : 이벤트 이름</li>
  <li>e.preventDefault : 이벤트의 전달을 막는 함수(이벤트버블링, 양식제출)</li>
</ul>
<h2>모던 자바스크립트의 이벤트 예제1</h2>
<p>요소의 속성으로 이벤트를 지정하는 것과 addEventListener 를 같이 사용하면?</p>
<input id="elem" type="button" value="클릭해주세요1">
<script>
  function handler1() { alert('감사합니다!')};
  function handler2() { alert('다시 한번 감사합니다!')};

  elem.onclick = () => alert("안녕하세요.");
  elem.addEventListener("click", handler1); // 감사합니다!
  elem.addEventListener("click", handler2); // 다시 한번 감사합니다!
  // 클릭결과 3개 다 출력
</script>

<input id="elem2" type="button" value="클릭해주세요2">
<script>
  function handler1() { alert('감사합니다!')};
  function handler2() { alert('다시 한번 감사합니다!')};

  elem2.addEventListener("click", handler1); // 감사합니다!
  elem2.addEventListener("click", handler2); // 다시 한번 감사합니다!
  elem2.onclick = () => alert("안녕하세요.");
  elem2.onclick = () => alert("덮은 안녕하세요.");
  elem2.removeEventListener("click", handler2);

</script>
<input type="button" onclick="a()" value="클릭하세요">
<script>
  /*
    요소에 onclick을 정의하면z
    ="" 으로 이미 function 이벤트핸들러(콜백함수)가 정의되있음
    즉, 이벤트 콜백함수가 이미 정의되있기 때문에
    a 함수를 바로 쓸수없고(재정의할수없고), => onclick=a; (X)
    콜백함수(function(event){ "" })의 내부{" "}를 정의하는것.
   */

  function a(){
    alert("안녕");
    return "^^";
  }
//  console.log(a()); // 이건 내가 함수 실행시킨거 // 함수를 실행. 실행된 결과가 뜸 = "^^"
  //console.log(a);   // 이건 그냥 함수. 함수를 참조. 함수 전체가 뜬다. 함수자체.

  function Element(){ // 요소(노드)의 타입 // 필드 여러개
    this.src="",
    this.clientWidth="",
    this.className="",
    this.id="",
    this.onclick=function(e){}, //onclick은 함수가 타입 // onclick 필드(함수)는 아무것도 없는 기본값. 함수
    // node.onclick=a();
    // => this.onclick= "^^";
    // node.onclick=a;
    // => this.onclick=function(e){alert("안녕"); return "^^";}
    this.onmouseover=function(e){}
  }

  // onclick을 재정의 해야 재정의한 핸들러(콜백함수)가 실행된다.
  const node=new Element();
  //node.onclick=a(); // a함수의 실행 // "^^"
  // node.onclick=a;   // 함수자체 // 재정의한 함수 onclick 이벤트속성에 참조. // function(e){alert("안녕"); return "^^";}
  // => a; 함수 실행은 이벤트 핸들러가 클릭이벤트를 감시하고 있다가 이벤트가 발생하면(onclick 에 참조한 경우 click 이벤트 발생하면 이벤트 리스너가 실행해준다.).
  // 재정의한 a 함수가 실행된다.
  //
  // node.onclick=function(e){ // onclick 함수 재정의
  //   alert("안녕");
  //   return "^^";
  // }

  /*



  function handler() {}
  handler()
  handler;

  */



</script>

<h2>PointerEvent(MouseEvent) Object 내역 예제</h2>
<p>마우스에서 발생하는 이벤트에 대한 정보</p>
<p id="clientInfo"></p>
<p id="domInfo"></p>
<p id="nodeInfo"></p>
<p id="screenInfo"></p>
<style>
  #ball {
    border: 4px solid;
    width: 100px;
    height: 100px;
    /* 높이를 지정한것을 100%인 것과 실제 수치는 다르기 때문에 node.clientHeight 로 찾아야 한다. */
    position: absolute;
    /*position: absolute;   <!-- 절대적 위치 , 레이아웃과 별도의 위치 document가 따로 생성된것과 같다 -->*/
    /*position: relative; <!-- 요소를 기준으로 이동. 상대적 -->*/
    /* 부모가 상대적 위치일 때 부모기준으로 바뀐다 */
    margin: 0;
    left: 0px;
    top: 0px; /* 전체 document 를 기준으로 움직인다. */
    transition: all ease-in 300ms; /* left, top 위치가 바뀔때 변화되는 속도 ease-in */ /* ms : 밀리세컨즈 */
    border-radius: 50%;
    background-color: white;
    box-sizing: border-box;
  }
</style>
<div id="ex3Container"
     style="
     width: 300px;
     height: 300px;
     border: 2px solid;
     position: relative;
     box-sizing: border-box;
     background-color: green; ">
  <p id="ball"></p>
</div>
<script>
  const ball=document.getElementById("ball");
  const ex3Container=document.getElementById("ex3Container");

  ex3Container.onclick=function(e) { // onclick - pointerEvent // onmouseover -> MouseEvent // onmousemove 움직일때마다 위치 표시된다
    console.log(e); //MouseEvent>PointerEvent(브라우저에서 마우스 위치) // 부모자식 관계, 둘다 합쳐서 마우스이벤트라고 한다.  - 마우스의 위치정보가 나온다.
    // clientInfo,domInfo,nodeInfo,screenInfo
    clientInfo.innerText=`x: ${e.clientX}, y: ${e.clientY} (브라우저)`;  // 브라우저(보여지는 화면)에서의 위치
    domInfo.innerText=`x: ${e.pageX}, y: ${e.pageY} (html 문서)`;     // html 도큐먼트를 기준으로
    nodeInfo.innerText=`x: ${e.offsetX}, y: ${e.offsetY} (노드 개체)`;  // 이벤트가 발생한 노드 // 좌표가 - 나오는 이유는 마우스포인터가 범위를 넘어가서  // 노드를 기준으로 // exContainer 안
    screenInfo.innerText=`x: ${e.screenX}, y: ${e.screenY} (모니터)`;  // 모니터위치를 기준으로

    // style 에서 크기는 단위가 무조건 존재해야한다. 0을 제외하고 => px, %, em ...
    // px 는 모니터 단위(1980*10180) 기준으로 위치. 픽셀px
    // 컨테이너 너비 값을 구하기! => node.clientHeight 로 구할수 있다. // 자신 node 가 브라우저에서 나타나는 너비 // clientX와 관계 없다.
    console.log('ex3Container.clientWidth',ex3Container.clientWidth, 'ex3Container.clientHeight',ex3Container.clientHeight);
    // let containerWidth=parseInt(ex3Container.style.width); // 요소에 직접 적용한 스타일만 찾을 수 있다.
    // let containerHeight=parseInt(ex3Container.style.height);
    // 너비를 비교연산으로 비교하려면 300px 를 숫자로 만들어야 한다 -> parseInt // Number.parseInt Number생략가능
    // 자바스크립트로 노드에 적용된 최종의 스타일을 찾는 것에 한계가 있다.! (제이쿼를 사용하면 가능)
    let containerWidth=ex3Container.clientWidth; // node에 적용된 실제 넓이와 높이(px)
    let containerHeight=ex3Container.clientHeight;
    console.log(containerWidth, containerHeight);

    let ballWidth=ball.clientWidth;
    let ballHeight=ball.clientHeight;
    let borderWidth=9;

    if((e.offsetY-ballHeight/2)<0) { // 머리가 나가는 만큼 0보다 작으면 안되서 0으로 고정
      ball.style.top="0";
    } else if ((e.offsetY+ballHeight/2) >containerHeight) {
      ball.style.top=containerHeight - ballHeight -borderWidth +"px"; // 테두리사이즈 뺀 높이 // 볼사이즈 크기만큼 빼준다.
    }
    else {
      ball.style.top=(e.offsetY-ballHeight/2)+"px"; // 볼의 중앙에 마우스가 위치하도록
    }

    if((e.offsetX-ballWidth/2)<0) { // 머리가 나가는 만큼 0보다 작으면 안되서 0으로 고정
      ball.style.left="0";
    } else if ((e.offsetX+ballWidth/2)>containerWidth) {
      ball.style.left=containerWidth-ballWidth-borderWidth+ "px";
    }
    else {
      ball.style.left=(e.offsetX-ballWidth/2)+"px"; // 볼의 중앙에 마우스가 위치하도록
    }


    // if((e.offsetY-50)<0) { // 머리가 나가는 만큼 0보다 작으면 안되서 0으로 고정
    //   ball.style.top="0";
    // } else if (e.offsetY+50>300) {
    //   ball.style.top="195px"; // 테두리사이즈 뺀 높이 // 볼사이즈 크기만큼 빼준다.
    // }
    // else {
    //   ball.style.top=(e.offsetY-50)+"px"; // 볼의 중앙에 마우스가 위치하도록
    // }
    //
    // if((e.offsetX-50)<0) { // 머리가 나가는 만큼 0보다 작으면 안되서 0으로 고정
    //   ball.style.left="0";
    //  } else if ((e.offsetX+50)>300) {
    //   ball.style.left="195px";
    // }
    // else {
    //   // ball.style.top=(e.offsetY-50)+"px"; // 볼의 중앙에 마우스가 위치하도록
    // }





    // const ballY = (e.offsetY-50);
    // if(e.offsetY>500) {
    //   ball.style.bottom=e.offsetY+50+"px";
    // }
    // if((e.offsetY-50)>0) {
    //     // ball.style.top=(e.offsetY-104)+"px";
    //   // ball.style.bottom=(e.offsetY-104)+"px";
    //   // ball.style.top=((e.offsetY-50))+"px";
    //   ball.style.top = (ballY-104)+"px";
    //   //  ball.style.bottom="500px";
    //    // ball.style.bottom=e.offsetY-104+"px";
    // }

    // ball.style.left =(e.offsetX-50)+"px"; // html, xml의 모든 값은 문자열


    // 힌트! css 는 단위를 무조건 작성해야 한다.
    // ball.onclick=function(e) {
    //   ball.style.left="200px"; // 단위가 꼭 같이 적혀여야 함.
    //   ball.style.top="300px";
    // }
    // ball.style.left="this.clientXpx";
    // e.clientX : (수) 브라우저(윈도우) 전체 크기를 기준으로 마우스 포인트의 x축 위치
    // e.offsetX : (수) 노드(요소 ex) 버튼)를 기준으로 마우스 포인트의 x축 위치
    let left = 40 + "px"; // px를 따로 줘야한다.

    // let left3 = e.clientX -
    // console.log(event.clientX, event.clientY);
    // console.log(event.currentTarget);
    console.log(event.offsetX);
    //
    // if(e.clientX>e.offsetX && e.offsetY<e.clientY) {
    //   ball.style.left=e.offsetX+"px";
    //   ball.style.top=e.offsetY +"px";
    // }
    // ball.style.left=e.offsetX+"px";
    // ball.style.top=e.offsetY +"px";

  }

</script>
<style>
  #dropDownMenu {
    display: flex;
    margin-bottom: 500px;
    list-style: none;
  }
  #dropDownMenu>li {
    padding: 10px 20px;
    border: 2px solid;
    position: relative;
  }
  #dropDownMenu .menu { /* li 태그가 플렉스가 되면서 .menu도 부모크기만큼 가지게됨 */
    list-style: none;
    position: absolute; /* 메뉴가 대메뉴 li 에 포함되지 않고 독립적으로 포지션설정 가능 */
    /*border: 1px solid;*/ /* 애니메이션시 선 생긴다. -> 선쓰고 싶으면 li에 보더 주기?? */
    padding: 0;
    /*padding: 10px 20px;*/
    left: 0;
    top: 40px;
    width: 200px;
    max-height: 0;
    opacity: 0;
    /* contents 높이와 상관없이 해당노드의 높이의 최댓값
       max-height : 10000px; 내용(컨텐츠) : 20px;    => 노드 = 20px
       max-height : 10000px; 내용(컨텐츠) : 12000px; => 노드 = 10000px // 내용은 max-height를 못넘어 간다.
     */
    overflow: hidden;
    background-color: lightblue;
    transition: all linear 1s;
    /* 수치가 없는 속성은 애니메이션 적용이 안된다! (opacity(투명도), height, width) - display none 은 적용이 안된다 */
  }
  #dropDownMenu .menu>li {
    padding: 10px 20px;
    border-bottom: 1px solid;
  }
  #dropDownMenu .menu>li>a {
    text-decoration: none;
    color: black;
  }

</style>

<h2>열렸다 닫히는 메뉴 만들기</h2>
<p>#dropDownMenu li에 마우스를 올리면 li의 마지막 자신인 ul.menu 를 화면에 보이게 하세요</p>
<!--ul#dropDownMenu>li*4>strong{대메뉴$$}+(ul.menu>(li>a[href='#']{소메뉴$$})*4)--> <!-- [href='./']  주소 쓰는 법 -->
<!--emmet 플러그인 : 생산성-->
<ul id="dropDownMenu">
  <li><strong>대메뉴01</strong>
    <ul class="menu">
      <li><a href="#">소메뉴01</a></li>
      <li><a href="#">소메뉴02</a></li>
      <li><a href="#">소메뉴03</a></li>
      <li><a href="#">소메뉴04</a></li>
    </ul>
  </li>
  <li><strong>대메뉴02</strong>
    <ul class="menu">
      <li><a href="#">소메뉴01</a></li>
      <li><a href="#">소메뉴02</a></li>
      <li><a href="#">소메뉴03</a></li>
      <li><a href="#">소메뉴04</a></li>
    </ul>
  </li>
  <li><strong>대메뉴03</strong>
    <ul class="menu">
      <li><a href="#">소메뉴01</a></li>
      <li><a href="#">소메뉴02</a></li>
      <li><a href="#">소메뉴03</a></li>
      <li><a href="#">소메뉴04</a></li>
    </ul>
  </li>
  <li><strong>대메뉴04</strong>
    <ul class="menu">
      <li><a href="#">소메뉴01</a></li>
      <li><a href="#">소메뉴02</a></li>
      <li><a href="#">소메뉴03</a></li>
      <li><a href="#">소메뉴04</a></li>
      <li><a href="#">소메뉴04</a></li>
    </ul>
  </li>
</ul>
<script>
  <!-- 프론트엔드+(퍼블리싱이되는) 개발자 -->
  // const dropDowndMenu = document.getElementById("dropDownMenu"); // <ul></>ul>
  // const dropDownMenuLis=dropDowndMenu.getElementsByTagName("li"); // ElementsByTagName 자손
  // const dropDownMenuLis = ddMenu.children;
  const dropDownMenuLis = document.querySelectorAll("#dropDownMenu>li"); // nodeList // li 대메뉴 여러개
  dropDownMenuLis.forEach((li)=>{ // li 대메뉴
    // console.log(li.lastElementChild); // ul.menu
    li.onmouseenter=function(e) {
      li.lastElementChild.style.height="auto"; // default값 : 컨텐츠의 높이만큼 부모의 높이가 따른다. // 이걸 써야 mxHeight이랑 같이 쓸때, 메뉴가 다음메뉴 나오는거 기다리지 않고 바로 나온다
      li.lastElementChild.style.maxHeight = "500px"; // 대충 엄청 크게 하기  - maxHeight보다 값이 낮은 경우 안에 내용은 컨텐츠의 높이만큼 나온다. // 부모(대메뉴)의 높이를 기준으로 자식이 100%로 따른다.
      li.lastElementChild.style.opacity="100%";
    }
    li.addEventListener("mouseleave", (e) => {
      li.lastElementChild.style.height="0"; // 대충 엄청 크게 하기  - maxHeight보다 값이 낮은 경우 안에 내용은 컨텐츠의 높이만큼 나온다. // 부모(대메뉴)의 높이를 기준으로 자식이 100%로 따른다.
      li.querySelector(".menu").style.maxHeight="0px";
      li.lastElementChild.style.opacity="0";
    })
  })

</script>


<!--

// 모던자바스크립트 예제
// 1. script 태그 안에 있을때 호출방법
// node.onclick=countRabbits; // 함수참조. 클릭하면 이벤트리스너가 함수 실행
// 2. 요소에 onclick 을 줄때
// <input tyle="button" onclick="countRabbits()" value="토끼를 세어봅시다!">
// countRabbits(); // 이렇게 함수 호출해야함. // 익명함수 안에서 실행을 정의
// countRabbits;   // 이렇게 사용 X
// onclick=function(event){ countRabbit(); } // onclick="countRabbits()" 과 동일
// 이때는 함수 실행해야 해서 countRabbit(); 써야함 // countRabbit; 안됨
// HTML 속성 값에는 괄호가 있어야함.

// 이벤트 함수의 매개변수 e는 써도되고 안써도 된다.


-->
<script>
  // 기본형을 제외하고는 무엇이든 간에 다른것이 생성된다. 함수형, 문자열, 타입 /  자료형, 배열, 오브젝트함수, 일반함수, 화살표 함수 전부 다
  // 똑같은 함수라는건 완전 똑같은 거. 변수가 똑같은 주소를 참조하고 있는 함수 등을 말한다.
  // 똑같이 써서 같은거는 기본형 밖에 없다. ex ) "안녕" == "안녕"
  const func=()=>{alert("안녕!"); return "^^"}
  const func2=()=>{alert("안녕!")}
  const func3=function(){ alert("안녕!") }
  const func4=function(){ alert("안녕!") }
  // func(); // 함수실행
  // console.log(func());
  // console.log(func);
  console.log(func == func2); // false
  console.log(func == func);  // true


  // 같은 함수 예제
  // function handler() {
  //   alert( '감사합니다!' );
  // }
  //
  // input.addEventListener("click", handler); // 동일한 함수
  // input.removeEventListener("click", handler);

</script>

<!--
// 자바문법
js EventListener == 자바 swing에서 addActionListener
JButton btn=new JButton("제출");
btn.addActionListener((ActionEvent e) -> { // ((e)-> {})
}); // 마우스로 버튼을 누르는 이벤트를 재정의  / 이벤트를 재정의하는 함수 == 콜백함수
-->


</body>

</html>