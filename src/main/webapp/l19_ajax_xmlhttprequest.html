<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>비동기식 통신 ajax</title>
</head>
<body>
    <h1>Asynchronous JavaScript And XML</h1>
    <p>자바스크립트로 xml을 비동기식 통신으로 불러오는 것!</p>
    <ul>
        <li>http 통신에서 동기식이란? : 브라우저가 url 로 요청한 페이지 1개를 로드하는 것(일반적)</li> <!-- 브라우저가 url 로 요청한 페이지 : 톰캣서버에 있는 리소스를 요청하는 것 // http 통신은 기본적으로 웹서버가 있다. 그안에 동적리소스 정적리소스 등이 있다. 둘다 html로 반환된다. html을 요청하는 것 -->
        <li>http 통신에서 비동기식이란? : 브라우저가 로드한 페이지에서 다른 페이지를 요청하는 것(특수) - AJAX</li> <!-- // 능률적이다. 네이버 회원가입시 아이디검사할때, 체크하는 페이지를 회원가입페이지 내부로 가지고 있다. -->
        <li>xml : 비동기식 통신에서의 xml 은 html 문서를 의미한다.</li> <!-- xml 은 html 의 부모. 태그로 되어있는게 모두 xml/ html 은 규정되어있는거 -->
        <li>자바스크립트로 비동기식 통신 : js의 XMLHTTPRequest 객체가 비동기식 통신을 하도록 지원한다. </li>
        <li>AJAX : 자바스크립트로 비동기식 통신을 하면 AJAX 라고 부른다.</li>
    </ul>
    <h2>AJAX 의 등장이유?</h2>
    <ul>
        <li>한개의 url 의 문서를 1번 로드(저장)하는 브라우저의 인터페이스가 불편해서 등장</li>
        <li>작은 데이터를 얻기위해 전체 페이지를 로드하는 것이 비효율적(비용)이라서</li> <!-- ex) 네이버 회원가입 시 아이디 중복체크할때 아이디를 검사할 전체페이지가 필요함 -->
        <li>문서를 요청할 때마다 중복되는 리소스를 매번 다운로드 받는다(비용증가, 브라우저가 캐쉬로 저장을 해서 조금 만회하는 중)</li> <!-- 페이지의 기본고정 - 로고, 메뉴, 등등.. => 중복되는 리소스 -->
        <li>유저 인터페이스를 편하게 하고 비용을 절감한다</li> <!-- 문서요청 -> 서버간 통신 -> 그때마다 트래픽 발생 -> 클라이언트가 다운받는 게 많을 수록 트래픽 증가할수록 통신회사에서, 서버회사에서 돈을 많이내라고 한다 - 통신회사 ex) kt, lg유플러스 -->
    </ul>
    <p>
        <button id="loadDomBtn">ajax/imgList.html 문서 불러오기</button> // 문서가 로드됬는데 다른 문서를 불러오는 것
    </p>
    <div id="ajaxContainer" style="border: 1px solid">
    </div>
    <script>
        loadDomBtn.onclick=function (e) {
            let url="ajax/imgList.html"; // 404 에러 페이지는 톰캣이 주는것.
            const req=new XMLHttpRequest(); // 다른 페이지를 요청
            req.open("GET", url); // open() 준비단계 셋팅작업 // 양식 제출 : POST , url 제출 : GET
            req.onload=function(e){ // request 가 성공한 시점이 onload 이다. // onload == onclick 과 같은 역할. 이벤트가 발생한 시점
                // onload :
                // 통신에 성공했을때(이벤트) 실행되는 콜백함수를 정의 (왜? 몇초만에 받아올지 알 수 없기 때문에)
                // 통신에 걸린 시간이나 어떤 통신인지에 대한 내역을 포함
                // console.log(e); // e 는 event 정보
                // console.log(req.responseText);// 받아온 문서(통신의 내역)를 문자열로 반환한것
                ajaxContainer.innerHTML=req.responseText;
            }

            req.send(); // 해당 url의 문서를 불러온다.(실제호출) -> 성공이벤트가 발생하길 기다린다. 성공시점(onload). 성공이벤트가 onload=function(){} // 브라우저가 서버에 문서를 요청. // 요청해서 도착한 시점 이 onload.
            // 문서를 요청하면 받아오는데 까지 시간이 조금 걸린다..
            // setTimeout 으로 시간을 지정하는 방식 -> 컴퓨터마다 다르다. -> ***언제 받아오는지 알 방법이 없다. => 성공한 시점에서 받아오는 게 좋다!! onload
            // setTimeout(()=>{
            //     console.log(req.responseText);// 불러온 문서의 문자열 // 양식 제출 : POST , url 제출 : GET
            // },2); //

        }
    </script>
    <form name="signupForm" action="/a.html">
        <div>
            <p> <!--// 입력하는 거 oninput // 값을 입력하고 바깥을 클릭하면 발생하는 이벤트 onchange -->
                <label>id :
                    <input name="userId" placeholder="id를 입력하세요">
                </label>
            </p>
            <p id="userIdMsg"></p>
        </div>
    </form>
    <script>
        const signupForm=document.forms["signupForm"];
        signupForm.userId.onchange=function(e){
            let val=this.value; // this 는 userId
            // 입력받은 아이디가 중복되었는지 서버에 물어본다
            let url="ajax/idCheck.json"; // id체크하는 서버의 url. 동적페이지. 결과(true,false)가 항상 바뀐다. 결과가 true 면 멋진아이디. false면
            const req=new XMLHttpRequest(); // 통신하는 객체 //다른페이지를 요청
            req.open("GET",url); // 호출방식 셋팅
            // => emp.empno 가 중복되어 있는지 확인하는 동적페이지를 작성하면 된다! // idCheck.json 파일 위에 L14EmpList 파일과같은 내역이 있는것이다. (눈에는 안보이지만)
            req.onload=function(e) { // 호출되는 시점에서 발생되는 이벤트
                let jsonStr=req.responseText; // 요청한 문서 let url 주소란에 넣은 주소. 문자. 를 문자열로 해석 응답받은 문서
                const checkObj=JSON.parse(jsonStr);
                // JSON.parse() : 문자열인 json을 Object 로 형변환 하는 함수
                console.log(jsonStr);
                console.log(b.check);
                let a = `{"age":37, "check" : false, "id":"ckm"}`; // => jsonStr : 문자열. 문자열에서 값을 찾을수. 없다.
                let b={check:false} // 오브젝트를 형변환 하여. 값을 출력할 수 있게 된다.

                // `{오브젝트}`
                console.log(checkObj);


                let msg=(checkObj.check)?"멋진 아이디" : "사용중인 아이디";
                userIdMsg.innerText=msg;
            }
            req.send();
        }
    </script>

    <ul>
        xml json 차이점

        xml : xml은 태그로 "<check>true</check>"                 // 문자열 인데 형식이 문서이다. // 돔트리를 이용해서 값을 가져오기 위한 목적으로 만들어짐 // 태그 안에 있는 값 // 오브젝트가 될 수 없다. // 마크를 하면  value 를 true 라는 문자열을 가져오기 위한
        json : {check : true} // 오브젝트를 명세서(문자열)로 표현한것 // json 인데 문자열이다      // 문자열을 오브젝트로 만들어서 값을 가져온다

        xml : value 를 문자열로 전달하기 위해 태그로 감싼것. 텍스트 노드
        돔트리의 마지막 노드는 텍스트 노드 = true 가 문자열인지 타입이 true 인지 알수가 없다.

        json :
        오브젝트는 문자열 "" 표시를 안하면 문자열을 만들때 boolean 으로 형변환 한다.
        오브젝트는 타입이 존재한다 -> 문자열, 숫자형, null ..
        타입도 있고, key 도 있고, 배열도 있다.

        xml 은 문자열 값만 갖는다 => 텍스트 노드로 돔트래블링으로 찾는다.

        json 의 장점?
        문자열의 길이가 짧다(데이터값이 적다)
        값의 타입이 존재한다. 문자열 뿐 아니라 Number, boolean, 문자열, null... (NaN, function, undefined 등은 안됨)
        value 검색이 쉽다. -> objec.필드명 으로 찾을 수 있다
        필드명을 잘못 쓰면 파싱오류가 생길수 있다. false -> flase 잘못적으면 형변환 안된다.

        -> 데이터 전송용으로 쓴다. 테이블로 쓸수있다.


        HTML- 화면을 구조화. 중첩관계 구조화, 화면구성을 정보화 - 처음에는 json 이 없어서 xml을 가져와서 화면을 구성함

        * 탄생목적 : 정보전달
        xml   - 마크업 / 정보(데이터)를 전달하기 위해
        json  - {} 오브젝트 / 정보(데이터)를 전달하기 위해. 데이터를 오브젝트로 정의하는

        브라우저가 서버에 html 파일을 요청
        서버가 html 파일을 문자열(0101010..)로 변환 및 브라우저에 전송 -> 확장된 문서 html 로 변환 -> 화면 출력


        동적페이지는 고정되있는 페이지가 아니다
        서버에서 한번 실행되서 매번 값이 바뀐다
        자바파일이 json 을 반환
        동적페이지가 무엇을 반환하는지에 따라 달라지는것.


    </ul>



</body>
</html>