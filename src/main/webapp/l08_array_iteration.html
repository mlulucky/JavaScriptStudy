<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>배열의 내부 반복문</title>
</head>
<body>
  <h1>배열의 선언과 내부 반복문과 정렬</h1>
  <h2>타입이 명확하지 않아서 발생하는 문제 해결을 위한 const 선언</h2>
  <ul>
    <li>자바의 변수 : ArrayList list = new ArrayList(); list=13;(x 컴파일 오류)</li>
    <li>js의 변수(타입이 없다) : let list = new Array(); list=13; (o 변수는 모든 타입을 참조가능)</li>
    <li>list Array 자료형이라 생각하고 있다가... 13으로 바뀐줄 모르고 list[3]을 참조하면 undefined 가 반환됨(왜? list[3]이 없는게 아니라 아예 13으로 자료가 바뀌어서)</li>
    <li>개발자들이 이런 상황을 피하고 싶어서 모든 자료형을 선언할 때 상수(const)로 선언하는 버릇이 있다.</li>
    <li>강제가 아니라 선택으로 필요에 따라 상수로 선언하면 된다.(모든 자료를 상수로 할 필요는 없다. 자료형의 타입을 바꿔야할 때도 있으므로(let))</li>
  </ul>
  <h2>배열의 내부반복문(Iteration 함수) 숙지하세요!!!</h2>
  <p>함수 실행시 Iterator 객체를 이용해 배열의 모든 필드에서 콜백 함수를 실행하는 반복문</p> <!-- 콜백함수 : 호출되는 함수 / 뭐든지 호출만 되면 콜백함수 -->
  <p>내부 반복문은 기본 함수를 정의하기 때문에 재사용성이 높고 가독성도 좋다.(개발자들이 선호)</p> <!-- 반복문이 계속 중첩되는 것보다 가독성이 좋다 -->
  <!-- 배열이 내부반복문을 가지고 있어야 사용 가능하다. -->
  <ul>
    <li>forEach((e,i,array)=>{}); : 각 요소를 검사하거나 소비하는 반복문</li>  <!-- 많이 사용  / e : 각 요소,  i : 인덱스, array : 배열-->
    <li>map((e,i,array)=>modify e); return new Array() : 배열의 각 요소의 값을 변경한 새로운 배열을 반환</li>  <!-- 많이 사용 -->
    <li>reduce((total,e,i,array)=> total 연산 e, total=val); return total : 모든 요소를 연산한 하나의 결과를 반환 // total과 요소 연산, total 값 선언</li> <!-- 많이 사용 -->
    <li>filter((e,i,array)=>(e 비교연산)); return new Array() : 조건(boolean)에 맞는 요소만 남긴 새로운 배열을 반환</li> <!-- 많이 사용 --> <!-- filter((e,i,array)=> boolean(e 비교연산)) return new Array() -->
    <li>every((e,i,array)=>(e 비교연산)); return boolean : ???</li>
    <li>some((e,i,array)=>(e 비교연산)); return boolean : ??</li>
    <li>find((e,i,array)=>(e 비교연산)); return 찾은요소 : ??</li>
    <li>findIndex((e,i,array)=>(e 비교연산)); return 찾은 요소의 Index : ??</li>
    <li>includes(찾는 값); return boolean : ??</li>
    <li>includes(찾는 값, start index=0); return index : ?? 앞에서 부터 찾는다</li>
    <li>lastIndexOf(찾는 값, start index=0); return index : ?? 뒤에서 부터 찾는다.</li>
  </ul>
  <h2>배열의 정렬 함수</h2> <!-- DB order by 로 정렬 다 되서 온다. -->
  <p>배열에 있는 요소가 정렬이 될때까지 반복하는 함수 기본은 문자열을 정렬</p>
  <ul>
    <li>Array.sort() : 문자열 오름차순(asc) 정렬</li>
    <li>Array.reverse() : 문자열 내림차순(desc) 정렬</li>
    <li>Array.sort((a,b)=>a-b) : 수의 오름차순 정렬(문자열을 빼기가 안되니까)</li>
    <li>Array.sort((a,b)=>b-a) : 수의 내림차순 정렬</li>
    <li>Object.sort((a,b)=>a.필드 - b.필드) : 자료형(객체)의 필드의 값으로 오름차순 정렬</li>
    <li>Object.sort((a,b)=>b.필드 - a.필드) : 자료형의 필드의 값으로 내림차순 정렬</li>
  </ul>
  <h2>Array 타입과 배열 자료형들</h2>
  <p>브라우저에서 js가 실행될 때 브라우저가 필요에 의해서 생성하는 배열들이 존재한다. 이 배열의 타입이 Array가 아니다.(유사배열)</p>
  <ul id="test" class="a b c d e"> <!-- 클래스명이 복수인 경우 -->
    <li>배열 : 자료에 순서가 있고(index) 길이가 있는 자료구조 (포괄적인 의미)</li> <!-- ★배열(<->자료형 차이점) : 고급 개발자가 되기위한 기본소양  -->
    <li>js.Array : 자바스크립트가 배열을 쉽게 선언하고 다룰 수 있도록 만든 타입</li> <!-- js의 array : 길이가 있고 참조키가 없는 (자료형은 참조키(필드)가 있다) -->
    <li>java.new 타입[] : 자바에서 index 와 길이만 있는 배열타입 (Array 라 부른다. 길이변경불가능, 가볍다, 기본형가능)</li>
    <li>java.util.ArrayList : Array 가 사용하기 불편해서 지원하려고 나온 자료형 (컬렉션 프레임워크, 무겁다, 자료형만가능)</li>
    <li>브라우저.HTMLCollection : 요소(node,노드개체)를 배열로 다루기 위해 최초로 등장한 자료형</li> <!-- 유사배열 --> <!-- 노드 ? 요소가 화면에 출력된 것 == 노드개체 -->
    <li>브라우저.NodeList : 노드 검색이 불편해서 jQuery 처럼 css 선택자로 검색가능한 함수 querySelectorAll 을 추가하면서 만든 배열(forEach가 있다)</li> <!-- 유사배열 -->
    <li>브라우저.DOMTokenList : classList 가 반환하는 배열로  class 를 다루기 위한 필드를 제공
      <ul> <!-- 숙제! 개념정리 -->
        <li>add() : </li>
        <li>remove() : </li> <!-- perviousSibling -->
        <li>toggle() : </li> <!-- 나 , 나를 기준으로 한 나의 형제 전체 선택_ 나의 부모의 자식 -->
        <li>contains() : </li>  <!-- nextSibling -->
        <li>forEach() : </li>
        <li>value : == className</li>
      </ul>
    </li>
    <li>브라우저.RadioNodeList : input type 이 radio 와 checkbox 인 노드를 검색하면 반환되는 배열로
        type 이 radio 인 경우 선택함. value 가 반환된다.
    </li> <!-- value를 알기위해 사용 -->


  </ul>
  <form name="signup">
    <p> <!-- checkbox 여러개 선택가능 -->
      낚시 <input type="checkbox" name="hobby" value="fishing">
      독서 <input type="checkbox" name="hobby" value="reading">
      그림 <input type="checkbox" name="hobby" value="painting">
      게임 <input type="checkbox" name="hobby" value="gaming">
    </p>
    <p> <!-- radio 한개만 선택가능 -->
      남자 <input type="radio" name="gender" value="남">
      여자 <input checked type="radio" name="gender" value="여">
    </p>
  </form>
  <h2>Array.from() Array 가 아닌 배열을 Array 로 바꿔주는 함수</h2>
  <p>자료형(Object)인데 키가 index처럼(수) 정의되어 있고 길이length 가 있는 것도 Array 바꿀 수 있다.</p>
  <script>
    console.log(document.querySelectorAll("li")); // NodeList 배열 반환 [li, li, li, ....li]
    console.log('test.classLIst');
    console.log(test.classList);  // DOMTokenList(5)['a', 'b', 'c', 'd', 'e', value: 'a b c d e'] // DOMTokenList : classList가 반환하는 배열 // class 명을 배열로 반환 <ul id="test" class="a b c d e"> <!-- 클래스명이 복수인 경우 -->
    // form 선택자 : document.forms.form name.태그name
    const hobbies = document.forms.signup.hobby;
    console.log(hobbies);
    const genders = signup.gender; // 이때 form태그 name  signup 은 id 처럼 미리 생성된 선택자. (id 처럼 취급한다)
    console.log(genders);


    const arr=[10,1,3,200,-300];

    // ▣ 외부반복문
    // 일반적인 반복문(외부반복문)
    for(let i=0; i<arr.length; i++) {
      // console.log(arr[i]);
      console.log(i,arr[i]); // i 는 index 로서 숫자로 체크
    }
    // Iterator 를 이용한 외부 반복문(for of)
    for(let num of arr) { // Iterator 의 hasNext() next()를 이용해(번갈아 호출) 배열에 있는 자료를 빼내는 방식
      console.log(num);
    }
    // 자료형의 key 를 이용해서 반복하는 외부 반복문(for in)
    for(let i in arr) { // 자료가 가진 모든 키가 반환
      console.log(i,arr[i]); // i를 key 로서 문자열로 체크
    }

    // ▣ 내부반복문
    // 내부 반복문은 해당 자료형에서 가지고 있어야 사용 가능(HTMLCollection document 에서 사용하는 배열에는 내부반복문(ex forEach)이 존재하지 않음)
    // 배열에는 내부반복문 forEach 가 있다.
    // 내부 반복문도 Iterator 객체를 이용해서 실행된다
    // 내부반복문 forEach 실행할때마다 매개변수 3개를 전달한다 - (인덱스, 값, arr전체 값)
    arr.forEach((num,i,array)=>{
      console.log(i,num,array);
    });

  </script>

</body>
</html>