<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>var 호이스팅 현상</title>
</head>
<body>
  <h1>var 의 호이스팅 현상</h1> <!-- var이 윈도우의 필드로 선언되어서 호이스팅현상이 생긴다 -->
  <p>hoisting 은 끌어올린다는 의미로 var이 지역에 선언되어도 전역에서 사용되는 현상을 의미한다.</p>
  <p>var 변수는 전역의 필드인 window에 선언되기 때문에 scope(영역)가 없고 무조건 전역에 호출된다.</p>
  <p>오류는 아니지만 지역변수가 없는 것은 프로그래밍이 어려워지거나 한계를 만들 수 있기때문에 let 을 만들었다.</p>

  <script>
    // 호이스팅 현상 예제
    var a=10; // 전역변수 // 전역 == 윈도우 전체영역
    {
        var a=20; // 지역변수
        console.log("지역의 a : " + a); // 20
    }
    console.log("전체의 a : " + a); // 20
    // 지역변수 a와 전역변수 a가 구분이 확실하다면, 독립적이라면 전역의 a가 10이어야 하는데 20이 된다.
    // 지역에서 선언했는데 전역의 변수가 바뀐다고 해서 hoisting 현상이라 한다. -> 사람들은 이걸 오류로 취급??

    let b=10; // 전역변수
    {
        let b=20; // 지역변수 // 자바스크립트에서는 블럭과 전역을 다르게 취급한다.
        console.log("지역의 b: " + b) // 20
    }
    console.log("전역의 b: " + b); // 10

    // java는 함수(메서드)안에서 부모영역에 선언한 변수이름을 자식 영역(ex) if문 등..)에서 사용할 수 없다. (클래스의 필드는 예외)
    // var 은 윈도우의 필드를 변수로 선언하는 명령어기 때문에 hoisting 현상이 발생한다.
    // window (전역) : 브라우저 객체로 js가 실행될때 브라우저와 관련된 모든 필드를 포함하는 최상위 객체
    // window.document : 브라우저에서 불러온 html 문서를 객체로 생성하는 것
    // window.document.(node 개체) : html 에 작성된 태그를 객체로 생성하는 것 (node : 가지에 달린 무언가)
    // DOMTree : html에 작성된 태그를 tree 의 형상으로 구성하는 것 (태그를 node라고 한다.) (자료구조에 달려있는 무언가를 모두 노드객체라고 한다)

    console.log(window); // 궁금증 - window라는 역할로 자바에서 같은 것은 없다. window 안에도 object 가 있다 (자바로 비교하자면 JVM과 같은거라고 생각.. - 브라우저를 실행하는 엔진같은 역할) 자바의 Object 와는 같지 않다. Object는 모든 타입의 부모
    console.log(window.document);
    // var a=10; window 필드로 a를 선언함 -> a는 무조건 전역이다. -> 오류가 아니다. 단지 스코프가 명확하지 않은 변수
    console.log(window.a) // a는 전역이다. window 는 스코프. 영역이 없다.
    // var a == window.a

    window.c=100 // var c=100;
    {
        window.c=10; // var c=10

    }
    console.log("c: " + c); // c == var c == window.c // 그냥 c라고 했는데 window.c 출력

    // var는 윈도우(브라우저 객체) 필드변수. 영역이 없다. { } 괄호안에 들어가도 이미 윈도우의 필드이므로 영역이 구분이 안되므로
    // 마지막으로 대입한 값이 결과값으로 출력된다.

  </script>



</body>
</html>